Phase 2.5 (Next Prompt): Knowledge-Docs → Artifacts → Engine Hooks (no rewrite)

You are working in an EXISTING full-stack TypeScript codebase (Vite + client/, server/). Do NOT rebuild greenfield.

GOAL
Make the whole app (simulator, dashboard, layout suggestions) “knowledge-powered” from /knowledge-docs and the existing RAG pipeline. Use hardcoded benchmarks only as FALLBACK.

STEP 0 — DISCOVERY (read-only)
- Inspect current repo structure (client/, server/, shared/ or packages/shared).
- Identify:
  - server entry file (index.ts/app.ts/main.ts)
  - current DB setup (Drizzle config, migrations folder)
  - existing RAG endpoints (if any) and Tavily integration location
  - where simulator logic lives (files/functions) and where dashboard score is computed

STEP 1 — DB: Add knowledge_artifacts
Create a migration + Drizzle schema for table `knowledge_artifacts`:

Columns:
- id uuid PK
- tenant_id uuid NULL (prepare multi-tenant, keep null for now if not implemented)
- artifact_type text CHECK IN ('rule','benchmark','formula','template','checklist','playbook')
- module text CHECK IN ('dashboard','layout','staffing','scheduling','hygiene','billing','marketing','qm')
- topic text NOT NULL
- payload_json jsonb NOT NULL
- source_citations jsonb NOT NULL  -- array of {doc_name, heading_path, chunk_id}
- confidence real NOT NULL DEFAULT 0.0
- version int NOT NULL DEFAULT 1
- created_at timestamptz DEFAULT now()

Add shared types + zod schemas:
- shared/taxonomy.ts (enums + types)
- shared/artifacts.schema.ts (zod validation for payload_json per artifact_type)

STEP 2 — Script: Build artifacts from knowledge_chunks
Add script: `npm run build:artifacts` in server/package.json (or root scripts if mono).
Implementation requirements:
- Read existing `knowledge_chunks` from DB, grouped by (doc_name, heading_path).
- Call ChatGPT-4o to extract STRICT JSON artifacts matching the zod schema.
- Store to `knowledge_artifacts` with source_citations referencing the chunk_ids used.
- Idempotency:
  - Compute a stable hash from the input chunk_ids+content_hash for each heading group.
  - If hash unchanged since last build, skip.
- Generate minimum artifacts:
  - 5 for module='dashboard' (drivers + recommended actions)
  - 3 for module='staffing' (benchmarks + coverage rules)
  - 3 for module='layout' (flow/zonierung rules)
Return logs: created/updated/skipped counts.

STEP 3 — Engine Hooks (minimal invasive)
Wire artifacts into existing logic WITHOUT rewriting major components:
A) Dashboard:
- Replace hardcoded recommendations/health score drivers with artifacts module='dashboard'.
- UI must show “Why” + citations.

B) Simulator:
- Before running a simulation, load artifacts for modules in ('scheduling','staffing','layout').
- Use them to fill DEFAULT parameters ONLY if user did not specify.
- Keep existing simulator calculation code; just inject defaults and rules.
- If artifacts missing: fallback to shared/benchmarks.ts (if exists) + log `missing_artifact(module,topic)`.

C) Layout Editor:
- Show suggestions/constraints from artifacts module='layout' matched by room types/zones (simple matching ok).

STEP 4 — Safety/UX rules
- No person scoring (stress/efficiency per named person). Only roles/avatars and process metrics.
- Never claim compliance (“DIN-konform” etc.). Use wording: “Hinweis/Orientierung”.
- Always show citations for knowledge-derived rules.

STEP 5 — Smoke tests
- Add at least:
  - 1 unit test validating artifact JSON against zod schema
  - 1 smoke test that simulator can run with artifacts loaded
- Provide a short HOWTO:
  1) npm run ingest:knowledge
  2) npm run build:artifacts
  3) start app
  4) run one sim and show citations in dashboard

OUTPUT FORMAT
- List changed files
- Migration instructions
- Commands to run
- Any assumptions you made, written in README/PHASE_2_5_NOTES.md

Important: Do NOT delete existing files (e.g., benchmarks.ts) unless you confirm they are unused. Prefer fallback strategy.